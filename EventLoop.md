JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码，收集和处理事件以及执行队列中的子任务。
## 任务队列
JavaScript是单线程，单线程就意味着所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就必须得等待。
很多时候CPU是闲着的，但是因为IO操作很慢，不得不等着结果出来，才能往下执行。
JavaScript的设计者意识到，其实主线程完全可以不管IO操作，挂起处于等待中的任务（当前等待执行结果的任务），先运行排在后面的任务。等到IO操作返回了结果，再回过头，把之前挂起的任务继续执行下去。
因此，所有任务可以分成两种：同步任务和异步任务。同步任务是指，在主线程上排队执行的任务，只有前一个任务执行完成，才执行下一个任务；异步任务是指，不进入主线程，而是进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该异步任务才会进入主线程执行。
具体来说：异步任务的运行机制为：
+ 所有同步任务都在主线程上执行，形成一个执行栈。
+ 主线程之外，还有一个任务队列（本质是事件的队列）。只要异步任务有了运行结果，就在任务队列中放置一个事件。
+ 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列。执行栈就会执行任务队列里的对应的回调函数。
+ 主线程不断重复执行上面的步骤。
主线程从任务队列中读取事件，这个过程是循环不断地，因此这种运行机制又叫事件循环-Event Loop。
## 宏任务和微任务
以上事件循环只是一个宏观的，广义的描述。按照异步事件的类型，任务队列又会分为宏任务队列，微任务队列。宏任务会被添加到宏任务队列中，微任务会被添加到微任务队列中。
### 宏任务
script整体代码，setTimeout，setInterval等属于宏任务。
### 微任务
promise.then，process.nextTick等属于微任务。
宏任务和微任务虽然都是属于任务队列的范畴，但是执行的优先级不同，执行的顺序是不一样的。浏览器执行代码的时候，在一次事件循环中，执行一次宏任务，然后执行本轮事件循环中的所有微任务，即清空本轮事件循环中的微任务队列。然后再执行一次宏任务，再清空本轮事件循环中的微任务队列，如此循环往复的执行。




